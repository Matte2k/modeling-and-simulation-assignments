% Modeling and Simulation of Aerospace Systems (2023/2024)
% Assignment # 2
% Author: Matteo Baio 10667431

clearvars;  close all;  clc;
cmap = graphicSettings();
addpath("figures\");

%% Data input

% load all system data
CPUtimeCostIter   = 1;
caseModelSelector = 1;
[time, temp, nozzle] = initData(); 

% build boundary temperature function
temp.tInt = @(t) (t<1)  * (temp.tInt0 + ((temp.tInt1 - temp.tInt0).*t)/(time.t1 - time.t0)) + ...
                 (t>=1) * (temp.tInt1);
temp.tOut = @(t) temp.tExt;


%% Model build and simulation
% compute thermal resistance and capacitance from data
nozzle.lining    = cmpPart(nozzle.lining,    nozzle.section);
nozzle.conductor = cmpPart(nozzle.conductor, nozzle.section);
nozzle.insulator = cmpPart(nozzle.insulator, nozzle.section);
nozzle.coating   = cmpPart(nozzle.coating,   nozzle.section);

% compute mathematical model 
mModel = cmpMathModel(temp,nozzle);

odeOptions = odeset('MaxStep',0.1);
solverOpt  = solverSettings([time.t0,time.tf], [300,300], odeOptions, CPUtimeCostIter);

mModel.ode45  = mModelSolver(mModel, 'ode45', solverOpt);
mModel.ode89  = mModelSolver(mModel, 'ode89', solverOpt);
mModel.ode113 = mModelSolver(mModel, 'ode113', solverOpt);
mModel.ode15s = mModelSolver(mModel, 'ode15s', solverOpt);
%mModel.ode15i = mModelSolver(mModel, 'ode15i', solverOpt);

% compute simscape model
sModel.auto = execSimscapeModel('rocketNozzle', CPUtimeCostIter, caseModelSelector, [time.t0,time.tf]);


%% Result Plot

% Temperature nodes In and Out
figure(Name='input')
tiledlayout(2,1)
    nexttile
    hold on;    grid on;    axis padded;    box on;
    plot(mModel.ode45.time,  mModel.ode45.Ti,  'Color', cmap(1,:))
    plot(mModel.ode89.time,  mModel.ode89.Ti,  'Color', cmap(2,:))
    plot(mModel.ode113.time, mModel.ode113.Ti, 'Color', cmap(3,:))
    plot(mModel.ode15s.time, mModel.ode15s.Ti, 'Color', cmap(4,:))
    plot(sModel.auto.case1.time, sModel.auto.case1.T1 , 'Color', cmap(5,:))
    legend('ode45','ode89','ode113','ode15s','Simscape', Location='best')
    title('T intern')

    nexttile
    hold on;    grid on;    axis padded;    box on;

    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T outer')

% Temperature nodes 2 - 4
figure(Name='output 1')
tiledlayout(2,1)
    nexttile
    hold on;    grid on;    axis padded;    box on;


    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T 2')

    nexttile
    hold on;    grid on;    axis padded;    box on;


    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T 4')

% Temperature nodes 1 - 3 - 5
figure(Name='output 2')
tiledlayout(3,1)
    nexttile
    hold on;    grid on;    axis padded;    box on;

    plot(sModel.auto.case1.time, sModel.auto.case1.T1 , 'Color', cmap(5,:))
    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T 1')

    nexttile
    hold on;    grid on;    axis padded;    box on;


    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T 3')

    nexttile
    hold on;    grid on;    axis padded;    box on;


    legend('ode45','ode89','ode113','ode15s', Location='best')
    title('T 5')


% CPU-Time cost histogram
plot.timeCostVec = [mModel.ode45.CPUtime mModel.ode89.CPUtime mModel.ode113.CPUtime mModel.ode15s.CPUtime];
plot.timeLabel   = categorical({'ode45', 'ode89','ode113','ode15s'});
plot.timeLabel   = reordercats(plot.timeLabel,{'ode45', 'ode89','ode113','ode15s'});
figure(Name='time cost')
    hold on;    grid on;    axis padded;    box on;
    bar(plot.timeLabel,plot.timeCostVec)
    ylabel('Time cost [s]');


%% Eigenanalysis
figure(Name='Eigenvalues')
    hold on;    grid on;    axis padded;    box on;
    plot(real(mModel.lambda), imag(mModel.lambda),  'o')
    yline(0)
    xline(0)


%% FUNCTIONS

function [part] = cmpPart(part,crossSection)
%COMPUTE PART - compute thermal resistence and/or capacitance of the part
%if possible
%
%   COMPLETE DESCRIPTION HERE
%
%

    % Compute thermal resistence of the part if possible
    if ~isempty(part.k)
        part.K = part.l / (part.k * crossSection);
    end
    
    % Compute thermal capacity of the part if possible
    if ~isempty(part.c)
        part.C = part.c * (part.rho * part.l * crossSection);
    end

end


function [model] = cmpMathModel(temp,nozzle)
%COMPUTE MATHEMATICAL MODEL - compute the mathematical model of the system
%
%   COMPLETE DESCRIPTION HERE
%
%

    % Mathematical system thermal resistence
    model.R1 = (nozzle.lining.K);
    model.Ra = (nozzle.lining.K    + nozzle.conductor.K) * 1/2;
    model.Rb = (nozzle.conductor.K + nozzle.interface.K) * 1/2;
    model.Rc = (nozzle.interface.K + nozzle.insulator.K) * 1/2;
    model.Rd = (nozzle.insulator.K + nozzle.coating.K) * 1/2;
    model.R5 = (nozzle.coating.K);
    
    % Mathematical system thermal capacitance
    model.C2 = nozzle.conductor.C;
    model.C4 = nozzle.insulator.C;
    
    % Boundary temperature
    model.Ti = @(t) temp.tInt(t);
    model.To = @(t) temp.tOut(t);
    
    % Nodes temperature function
    model.T1 = @(Ti,T2) Ti*((2*model.Ra)/(2*model.Ra+model.R1)) + T2*(model.R1/(2*model.Ra+model.R1));
    model.T3 = @(T2,T4) T2*(model.Rc/(model.Rc+model.Rb)) + T4*(model.Rb/(model.Rc+model.Rb));
    model.T5 = @(T4,To) T4*(model.R5/(model.R5+2*model.Rd)) + To*((2*model.Rd)/(model.R5+2*model.Rd));
    
    % Differential system   [mSys.Tx(1)=T2  and  mSys.Tx(2)=T4]
    model.odeSys = @(t,Tx) [ 1/(model.C2) * ( (1/model.Ra)*(model.T1(model.Ti(t),Tx(1)) - Tx(1)) ...
                                            - (1/model.Rb)*(Tx(1) - model.T3(Tx(1),Tx(2)     ) ) )  ; ...
                             1/(model.C4) * ( (1/model.Rc)*(model.T3(Tx(1),Tx(2))       - Tx(2)) ...
                                            - (1/model.Rd)*(Tx(2) - model.T5(Tx(2),model.To(t)) ) ) ];
    % model.odeSys = @(t,Tx) [ 1/(model.C2) * ( Tx(1)*(model.R1/(model.Ra*(2*model.Ra + model.R1)) - 1/model.Ra - 1/model.Rb + model.Rc/((model.Rc + model.Rb)*model.Rb) ) ...
    %                                         + Tx(2)*(1/(model.Rc+model.Rb)) + model.Ti(t)*(2/(2*model.Ra+model.R1))  )  ; ...
    %                          1/(model.C4) * ( Tx(2)*(model.Rb/(model.Rc*(model.Rc + model.Rb)) - 1/model.Rc - 1/model.Rd + model.R5/(model.Rd*(model.R5 + 2*model.Rd)) ) ...
    %                                         + Tx(1)*(1/(model.Rc+model.Rb)) + model.To(t)*(2/(2*model.Rd+model.R5))  ) ];

    % State space matrix of the differential system (for eigenanalysis)
    model.eigSys = [ 1/(model.C2) * (model.R1/(model.Ra*(2*model.Ra + model.R1)) - 1/model.Ra - 1/model.Rb + model.Rc/((model.Rc + model.Rb)*model.Rb) ), ...
                     1/(model.C2) * (1/(model.Rc+model.Rb)) ; ...
                     1/(model.C4) * (model.Rb/(model.Rc*(model.Rc + model.Rb)) - 1/model.Rc - 1/model.Rd + model.R5/(model.Rd*(model.R5 + 2*model.Rd)) ), ...
                     1/(model.C4) * (1/(model.Rc+model.Rb)) ];
    model.lambda = eig(model.eigSys);

end


function [solverOpt] = solverSettings(timeLimit, initGuess, odeOptions, odeIter)
%
%   COMPLETE DESCRIPTION HERE
%
%
    if nargin < 4 || isempty(odeIter)
        odeIter = 1;
    end

    if length(timeLimit) == 1
        timeLimit(2) = timeLimit;
        timeLimit(1) = 0;
    end

    solverOpt = struct;
        solverOpt.time   = [timeLimit(1),timeLimit(2)];
        solverOpt.x0     = initGuess;
        solverOpt.odeOpt = odeOptions;
        solverOpt.iter   = odeIter;

end


function [modelSol, rawOdeSol] = mModelSolver(mModel, solverName, solverOpt)
%
%
%
%

    switch solverName
        case 'ode45'
            tic
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode45(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        case 'ode113'
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode113(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        case 'ode78'
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode78(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        case 'ode89'
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode89(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        case 'ode15s'
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode15s(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        case 'ode15i'
            for i = 1:solverOpt.iter
                [rawOdeSol.tVec,rawOdeSol.Tx] = ode15i(mModel.odeSys,solverOpt.time,solverOpt.x0,solverOpt.odeOpt);
            end
            modelSol.CPUtime = toc/solverOpt.iter;

        otherwise
            error('select a valide ode solver');
    end

    % Nodes temperature solutions
    modelSol.time = rawOdeSol.tVec;
    for i = 1:length(rawOdeSol.tVec)
        modelSol.Ti(i,1) = mModel.Ti(modelSol.time(i));
        modelSol.To(i,1) = mModel.To(modelSol.time(i));
    end

    modelSol.T1 = mModel.T1(modelSol.Ti,rawOdeSol.Tx(:,1));
    modelSol.T2 = rawOdeSol.Tx(:,1);
    modelSol.T3 = mModel.T3(rawOdeSol.Tx(:,1),rawOdeSol.Tx(:,2));
    modelSol.T4 = rawOdeSol.Tx(:,2);
    modelSol.T5 = mModel.T5(rawOdeSol.Tx(:,2),modelSol.To);

end


function [modelSol] = execSimscapeModel(modelName, timeCostIter, caseID, timeLimit, solverName, maxStep)
%
%
%
%
    
    % case model selector
    if nargin < 3 || isempty(caseID)
        caseID = 0;
    end

    % load simulink model
    load_system(modelName)
       
    % set simulink solver option for current model
    if nargin < 4 || isempty(timeLimit)
        set_param(modelName,'StopTime',  '60');
        set_param(modelName,'StartTime', '0.1');
    else
        set_param(modelName,'StopTime',  num2str(timeLimit(2)));
        set_param(modelName,'StartTime', num2str(timeLimit(1)));
    end

    if nargin >= 5 && ~isempty(solverName)
        set_param(modelName,'Solver', solverName);
    end

    if nargin >= 6 && ~isempty(maxStep)
        set_param(modelName,'MaxStep', maxStep);
    end

    % execute simulink model
    tic
    for i = 1:timeCostIter
        simulinkModel.simOut = sim(modelName);
    end
    modelSol.CPUtime = toc/timeCostIter;
    
    if caseID == 1 || caseID == 0
        % retrive simulink simulation solutions for model case 1
        modelSol.case1.Ti = simulinkModel.simOut.simlog.T;
        modelSol.case1.T1 = simulinkModel.simOut.simlog.T1_1.T.series.values('K');
        modelSol.case1.T2 = simulinkModel.simOut.simlog.T2_1.T.series.values('K');
        modelSol.case1.T3 = simulinkModel.simOut.simlog.T3_1.T.series.values('K');
        modelSol.case1.T4 = simulinkModel.simOut.simlog.T4_1.T.series.values('K');
        modelSol.case1.T5 = simulinkModel.simOut.simlog.T5_1.T.series.values('K');
        %modelSol.case1.To = simulinkModel.simOut.simlog.To_1.T.series.values('K');
        modelSol.case1.time = simulinkModel.simOut.simlog.T1_1.T.series.time;
    end

    if caseID == 2 || caseID == 0
        % retrive simulink simulation solutions for model case 2
        modelSol.case2.To = simulinkModel.simOut.simlog.To_2.T.series.values('K');
        modelSol.case2.T1    = simulinkModel.simOut.simlog.T1_2.T.series.values('K');
        modelSol.case2.T1    = simulinkModel.simOut.simlog.T1_2.T.series.values('K');
        modelSol.case2.T2in  = simulinkModel.simOut.simlog.T2_in_2.T .series.values('K');
        modelSol.case2.T2out = simulinkModel.simOut.simlog.T2_out_2.T.series.values('K');
        modelSol.case2.T3    = simulinkModel.simOut.simlog.T3_2.T.series.values('K');
        modelSol.case2.T4in  = simulinkModel.simOut.simlog.T4_in_2.T .series.values('K');
        modelSol.case2.T4out = simulinkModel.simOut.simlog.T4_out_2.T.series.values('K');
        modelSol.case2.T5    = simulinkModel.simOut.simlog.T5_2.T.series.values('K');
        modelSol.case2.To    = simulinkModel.simOut.simlog.To_2.T.series.values('K');
        modelSol.case2.time = simulinkModel.simOut.simlog.T1_2.T.series.time;
    end

    % export all the simulation log
    modelSol.simulationOutput = simulinkModel.simOut;
    modelSol.modelName = modelName;

    % close simulink model
    close_system(modelName,0);

end
