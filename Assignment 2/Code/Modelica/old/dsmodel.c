#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Baio232805_Assign2_Part1
 Dymola Version 2023 (64-bit), 2022-04-13 translated this at Fri Aug  2 09:59:00 2024

   */

#include <matrixop.h>
#include "matrixop.c"
static double DymArrays1[5]={0.0, 1.0, 1.0, 0.0, 0.0};
#if defined(DynSimStruct)
static double DymArrays0[7]={3.0, 2.0, 1.0, 0.0, -1.0, 1.0, 1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Math.Matrices.isEqual
discrete input Real M1[:, :] "First matrix";
discrete input Real M2[:, :] "Second matrix (may have different size as M1)";
discrete input Real eps(start = 0, min = 0.0) "Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) <= eps";
output Boolean result "= true, if matrices have the same size and the same elements";
protected 
Integer nrow(start = size(M1, 1)) "Number of rows of matrix M1";
Integer ncol(start = size(M1, 2)) "Number of columns of matrix M1";
Integer i(start = 1);
Integer j;
public 
algorithm 
result := false;
if (size(M2, 1) == nrow and size(M2, 2) == ncol) then 
result := true;
while i <= nrow loop
j := 1;
while j <= ncol loop
if (abs(M1[i, j]-M2[i, j]) > eps) then 
result := false;
i := nrow;
j := ncol;
end if;
j := j+1;
end while;
i := i+1;
end while;
end if;
end Modelica.Math.Matrices.isEqual;

  */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0) {
  PushContext("Modelica.Math.Matrices.isEqual")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nrow0_0;
    int   ncol0_0;
    int   i0_0;
    int   j0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nrow0_0 = DYNSizeSimple(M10_0, 1);
    ncol0_0 = DYNSizeSimple(M10_0, 2);
    i0_0 = 1;
    j0_0=0;
    /* Start of real code */
      result0_0 = false;
      if (DYNSizeSimple(M20_0, 1) == nrow0_0 AND DYNSizeSimple(M20_0, 2) == 
        ncol0_0) {
        result0_0 = true;
        while (i0_0 <= nrow0_0) {
          j0_0 = 1;
          while (j0_0 <= ncol0_0) {
            if (fabs(RealElement( M10_0, (SizeType)(i0_0), (SizeType)(j0_0))-
              RealElement( M20_0, (SizeType)(i0_0), (SizeType)(j0_0))) > eps0_0)
               {
              result0_0 = false;
              i0_0 = nrow0_0;
              j0_0 = ncol0_0;
            }
            j0_0 = j0_0+1;
          }
          i0_0 = i0_0+1;
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    6
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    98
#define NWP_   45
#define NP_    48
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -283957152
#define NHash2_ -530829628
#define NHash3_ 0
#define NI_    0
#define NRelF_ 5
#define NRel_  5
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    77
#define SizePre_ 1
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 55
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Baio232805_Assign2_Part1";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[13]={4 , 3 , 1 , 2 , 3 , 1 , 4 , 1 , 5 , 1 , 6 , 0
   , 0};
static int QJacobianGrp0[7]={3, 3, 3, 3, 3, 3, 0};
static int QJacobianGrp1[5]={1, 4 , 1 , 6 , 0};
static int QJacobianGrp2[6]={1, 5 , 2 , 5 , 6 , 0};
static int QJacobianGrp3[7]={6, 0, 6, 0, 0, 6, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[5]={
{0, QJacobianGrp0},{1, QJacobianGrp1},{1, QJacobianGrp2},{0, QJacobianGrp3},
  {0,0}};
DYMOLA_STATIC double QJacobianCD_[7]={0  , 44 , 55 , 66 , 70 , 72 , 72};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,46) = true;
DYNX(W_,47) = false;
DYNX(W_,48) = false;
DYNX(W_,49) = false;
DYNX(W_,50) = 2;
DYNX(W_,84) = 288.15;
DYNX(F_,0) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = false;
DYNX(W_,2) = true;
memcpy(&DYNX(W_,4), &DymArrays0, sizeof(double)*7);
DYNX(W_,16) = false;
DYNX(W_,19) = 3;
DYNX(W_,22) = 1;
DYNX(W_,24) = false;
DYNX(W_,25) = false;
DYNX(W_,37) = false;
DYNX(W_,40) = false;
DYNX(W_,44) = 3;
DYNX(W_,21) = 3;
DYNX(W_,26) = 3;
DYNX(W_,32) = 3;
DYNX(W_,18) = true;
DYNX(W_,1) = 0;
DYNX(W_,36) = 0;
DYNX(W_,17) = 0;
DYNX(W_,20) = 0;
DYNX(W_,29) = 0;
DYNX(W_,42) = 0.0;
DYNX(W_,41) = 0.0;
DYNX(W_,28) = false;
DYNX(W_,43) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(fabs(DYNX(DP_,3)) > 0,"abs(Gear_box.ratio) > 0", "Error in initialization of LossyGear: ratio may not be zero");
BoundParameterSection
DYNX(W_,11) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 2], Gear_box.lossTable[2, 2], Gear_box.lossTable[3, 2], Gear_box.lossTable[4, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,5), 
  DYNX(DP_,10), DYNX(DP_,15), DYNX(DP_,20)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,12) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 3], Gear_box.lossTable[2, 3], Gear_box.lossTable[3, 3], Gear_box.lossTable[4, 3]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,6), 
  DYNX(DP_,11), DYNX(DP_,16), DYNX(DP_,21)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(DYNhelp,0) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 4], Gear_box.lossTable[2, 4], Gear_box.lossTable[3, 4], Gear_box.lossTable[4, 4]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,7), 
  DYNX(DP_,12), DYNX(DP_,17), DYNX(DP_,22)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,13) = fabs(DYNX(DYNhelp,0));
DYNX(DYNhelp,1) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 5], Gear_box.lossTable[2, 5], Gear_box.lossTable[3, 5], Gear_box.lossTable[4, 5]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,8), 
  DYNX(DP_,13), DYNX(DP_,18), DYNX(DP_,23)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,14) = fabs(DYNX(DYNhelp,1));
DYNX(DYNhelp,2) = fabs(DYNX(W_,11)-1.0);
DYNX(DYNhelp,3) = fabs(DYNX(W_,12)-1.0);
DYNX(W_,15) = IF DYNX(DYNhelp,2) <= 1E-15 AND DYNX(DYNhelp,3) <= 1E-15 THEN 
  DYNX(W_,13)/(double)(2) ELSE divGuarded(DYNX(W_,13)-DYNX(W_,14),
  "Gear_box.tau_bf1_0-Gear_box.tau_bf2_0",DYNX(W_,11)-divinvGuarded(DYNX(W_,12),
  "Gear_box.eta_mf2_0"),"Gear_box.eta_mf1_0-1.0/Gear_box.eta_mf2_0");
DYNX(DYNhelp,4) = divinvGuarded(DYNX(DP_,30),"PID.Ti");
DYNX(W_,23) = DYNX(DYNhelp,4);
DYNX(W_,27) = DYNX(DP_,33);
DYNX(W_,30) = DYNX(DP_,31);
DYNX(DYNhelp,5) = divinvGuarded(DYNX(DP_,32),"PID.Nd");
DYNX(W_,31) = RealBmax(DYNX(DYNhelp,5)*DYNX(DP_,31), 1E-13);
DYNX(W_,33) = DYNX(DP_,34);
DYNX(DYNhelp,6) = fabs(DYNX(W_,30));
DYNX(W_,34) = DYNX(DYNhelp,6) < 1E-15;
DYNX(W_,35) = DYNX(DP_,29);
DYNX(W_,38) = DYNX(DP_,42);
AssertModelica(1+DYNX(DP_,43)*(DYNX(W_,38)-DYNX(DP_,42)) >= 1E-15,
  "1+Coil_resistance.alpha*(Coil_resistance.T_heatPort-Coil_resistance.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
BoundParameterConstantSection
DYNX(W_,3) = (PushModelContext(1,"Modelica.Math.Matrices.isEqual(Gear_box.lossTable, [0, 1, 1, 0, 0], 1E-15)")
  Modelica_Math_Matrices_isEqual(RealTemporaryDense( &DYNX(DP_,4), 2, 4, 5), 
  RealTemporaryDense( DymArrays1, 2, 1, 5), 1E-15));
PopAllMarks();
DYNX(W_,39) = DYNX(DP_,41)*(1+DYNX(DP_,43)*(DYNX(W_,38)-DYNX(DP_,42)));
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,3) = DYNX(W_,27);
DYNX(X_,4) = DYNX(W_,33);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,50);
InitialSection
InitialSection2
DYNX(W_,43) = 0.0;
DYNX(X_,4) = DYNX(W_,33);
DYNX(X_,3) = DYNX(W_,27);
InitialSection
InitialSection2
DYNX(W_,50) = DYNX(Aux_,0);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,1) = DYNX(X_,2);
if (NewParameters_) {
DYNX(DYNhelp,7) = divinvGuarded(DYNX(DP_,27),"Load_torque.w_nominal");
}
DYNX(W_,85) =  -DYNX(DP_,26)*sqr(DYNX(DYNhelp,7)*DYNX(X_,2));
DYNX(W_,97) =  -DYNX(DP_,45)*DYNX(X_,5);
DYNX(W_,56) = DYNX(DP_,3)*DYNX(X_,2);
DYNX(W_,58) = IF DYNX(W_,3) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 2], Gear_box.lossTable[2, 2], Gear_box.lossTable[3, 2], Gear_box.lossTable[4, 2]}, noEvent(abs(Gear_box.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,5), 
  DYNX(DP_,10), DYNX(DP_,15), DYNX(DP_,20)), fabs(DYNX(W_,56)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,62) = IF DYNX(W_,3) THEN 1 ELSE DYNX(W_,58);
DYNX(W_,59) = IF DYNX(W_,3) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 3], Gear_box.lossTable[2, 3], Gear_box.lossTable[3, 3], Gear_box.lossTable[4, 3]}, noEvent(abs(Gear_box.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,6), 
  DYNX(DP_,11), DYNX(DP_,16), DYNX(DP_,21)), fabs(DYNX(W_,56)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,63) = IF DYNX(W_,3) THEN 1 ELSE DYNX(W_,59);
DYNX(W_,60) = IF DYNX(W_,3) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 4], Gear_box.lossTable[2, 4], Gear_box.lossTable[3, 4], Gear_box.lossTable[4, 4]}, noEvent(abs(Gear_box.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,7), 
  DYNX(DP_,12), DYNX(DP_,17), DYNX(DP_,22)), fabs(DYNX(W_,56)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,66) = IF DYNX(W_,3) THEN 0 ELSE fabs(DYNX(W_,60));
DYNX(W_,61) = IF DYNX(W_,3) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({Gear_box.lossTable[1, 1], Gear_box.lossTable[2, 1], Gear_box.lossTable[3, 1], Gear_box.lossTable[4, 1]}, {Gear_box.lossTable[1, 5], Gear_box.lossTable[2, 5], Gear_box.lossTable[3, 5], Gear_box.lossTable[4, 5]}, noEvent(abs(Gear_box.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(DP_,4), 
  DYNX(DP_,9), DYNX(DP_,14), DYNX(DP_,19)), RealScalarArray ( 4, DYNX(DP_,8), 
  DYNX(DP_,13), DYNX(DP_,18), DYNX(DP_,23)), fabs(DYNX(W_,56)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,67) = IF DYNX(W_,3) THEN 0 ELSE fabs(DYNX(W_,61));
DYNX(DYNhelp,8) = fabs(DYNX(W_,62)-1.0);
DYNX(DYNhelp,9) = fabs(DYNX(W_,63)-1.0);
DYNX(W_,64) = IF DYNX(DYNhelp,8) <= 1E-15 AND DYNX(DYNhelp,9) <= 1E-15 THEN 
  DYNX(W_,66)/(double)(2) ELSE divGuarded(DYNX(W_,66)-DYNX(W_,67),
  "Gear_box.tau_bf1-Gear_box.tau_bf2",DYNX(W_,62)-divinvGuarded(DYNX(W_,63),
  "Gear_box.eta_mf2"),"Gear_box.eta_mf1-1.0/Gear_box.eta_mf2");

MixedSystemOfEquations(21, DYNX(DYNhelp,10))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 18 common subexpressions used in 22 expressions */
  /* Of the common subexpressions 18 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,31) = IF DYNX(W_,46) THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,32) = IF DYNX(W_,3) THEN 0.0 ELSE IF DYNX(W_,49) THEN 0.0 ELSE 
    IF DYNX(W_,47) OR PRE(DYNX(W_,50), 0) == 1 THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,33) = DYNX(DYNhelp,31)*DYNX(DYNhelp,32);
  DYNX(DYNhelp,34) = divinvGuarded(DYNX(W_,63),"Gear_box.eta_mf2");
  DYNX(DYNhelp,35) = 1-DYNX(DYNhelp,34);
  DYNX(DYNhelp,36) = IF DYNX(W_,3) THEN 0.0 ELSE IF DYNX(W_,49) THEN 0.0 ELSE 
    IF DYNX(W_,47) OR PRE(DYNX(W_,50), 0) == 1 THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,37) = DYNX(DYNhelp,31)*DYNX(DYNhelp,36);
  DYNX(DYNhelp,38) = 1-DYNX(W_,62);
  DYNX(DYNhelp,39) = IF DYNX(W_,46) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,40) = DYNX(DYNhelp,39)*DYNX(DYNhelp,36);
  DYNX(DYNhelp,41) = DYNX(DYNhelp,39)*DYNX(DYNhelp,32);
  DYNX(DYNhelp,42) = DYNX(DYNhelp,35)*DYNX(DYNhelp,37)+DYNX(DYNhelp,38)*
    DYNX(DYNhelp,40)+DYNX(DYNhelp,35)*DYNX(DYNhelp,41)+DYNX(DYNhelp,38)*
    DYNX(DYNhelp,33);
  /* Automatic tearing of linear system of 12 simultaneous equations
  gave a linear system of 3 equations for numerical solution.*/
  DYNX(DYNhelp,43) = DYNX(DP_,47)*DYNX(DYNhelp,42);
  DYNX(DYNhelp,44) = IF DYNX(W_,49) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,45) = IF DYNX(W_,49) THEN 0.0 ELSE -1.0;
  DYNX(DYNhelp,46) = DYNX(DP_,47)*DYNX(DP_,3);
  {
  const char*const varnames_[]={"Gear_box.sa", "Gear_box.tauLoss", 
    "Shaft_inertia.der(w)"};
  const double nominal_[]={1.0, 1.0, 1.0};
  DYNX(W_,55)=RememberSimple_(DYNX(W_,55), 0);
  DYNX(W_,76)=RememberSimple_(DYNX(W_,76), 1);
  DYNX(F_,2)=RememberSimple_(DYNX(F_,2), 2);
  SolveLinear3by3(DYNX(DYNhelp,43)*DYNX(DYNhelp,44)-(IF DYNX(W_,3) THEN 0.0
     ELSE IF DYNX(W_,49) THEN 1.0 ELSE 0.0), 1.0+DYNX(DYNhelp,43)*
    DYNX(DYNhelp,45), 0.0, 
  DYNX(DYNhelp,46)*DYNX(DYNhelp,44), DYNX(DP_,3)+DYNX(DYNhelp,46)*
    DYNX(DYNhelp,45), DYNX(DP_,28), 
  DYNX(DYNhelp,44), DYNX(DYNhelp,45),  -DYNX(DP_,3), 
  DYNX(DYNhelp,33)*DYNX(W_,66)-(DYNX(DYNhelp,42)*DYNX(W_,97)+DYNX(DYNhelp,37)*
    DYNX(W_,67)+DYNX(DYNhelp,40)*DYNX(W_,66))+DYNX(DYNhelp,41)*DYNX(W_,67),  -(
    DYNX(DP_,3)*DYNX(W_,97)+DYNX(W_,85)), 0.0, &DYNX(W_,55), &DYNX(W_,76), &
    DYNX(F_,2), 
  varnames_, &MixedFailFlag_, "simulation.linear[1]");
  }
  DYNX(W_,57) = IF DYNX(W_,49) THEN 0 ELSE DYNX(W_,55)-DYNX(W_,76);
  DYNX(W_,51) =  -(DYNX(DP_,47)*DYNX(W_,57)+DYNX(W_,97));
  DYNX(DYNhelp,47) = DYNX(DYNhelp,35)*DYNX(W_,51);
  DYNX(W_,71) = DYNX(DYNhelp,47)-DYNX(W_,67);
  DYNX(DYNhelp,48) = DYNX(DYNhelp,38)*DYNX(W_,51);
  DYNX(W_,70) = DYNX(DYNhelp,48)-DYNX(W_,66);
  DYNX(W_,78) = IF DYNX(W_,46) THEN DYNX(W_,71) ELSE DYNX(W_,70);
  DYNX(W_,69) = DYNX(DYNhelp,47)+DYNX(W_,67);
  DYNX(W_,68) = DYNX(DYNhelp,48)+DYNX(W_,66);
  DYNX(W_,77) = IF DYNX(W_,46) THEN DYNX(W_,68) ELSE DYNX(W_,69);
  DYNX(W_,52) =  -(DYNX(DP_,28)*DYNX(F_,2)+DYNX(W_,85));
   /* End of Equation Block */ 

  DYNX(W_,65) = IF DYNX(W_,3) THEN DYNX(W_,51) ELSE IF DYNX(W_,49) THEN 
    DYNX(W_,51) ELSE IF DYNX(W_,47) OR PRE(DYNX(W_,50), 0) == 1 THEN DYNX(W_,51)
    -DYNX(W_,64) ELSE DYNX(W_,51)+DYNX(W_,64);
  DYNX(W_,74) = (1-DYNX(W_,11))*DYNX(W_,51)-DYNX(W_,13);
  if (NewParameters_) {
  DYNX(DYNhelp,49) = divinvGuarded(DYNX(W_,12),"Gear_box.eta_mf2_0");
  }
  DYNX(W_,75) = (1-DYNX(DYNhelp,49))*DYNX(W_,51)-DYNX(W_,14);
  DYNX(W_,82) = DYNX(W_,51)+DYNX(W_,15);
  DYNX(W_,80) = IF DYNX(W_,82) > 0 THEN DYNX(W_,75) ELSE DYNX(W_,74);
  DYNX(W_,73) = (1-DYNX(DYNhelp,49))*DYNX(W_,51)+DYNX(W_,14);
  DYNX(W_,72) = (1-DYNX(W_,11))*DYNX(W_,51)+DYNX(W_,13);
  DYNX(W_,81) = DYNX(W_,51)-DYNX(W_,15);
  DYNX(W_,79) = IF DYNX(W_,81) > 0 THEN DYNX(W_,72) ELSE DYNX(W_,73);

  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,46),"Gear_box.tau_etaPos", GreaterEqual(
    DYNX(W_,65),"Gear_box.tau_eta", 0,"0", 0));
  UpdateVariableNamed(DYNX(W_,48),"Gear_box.startBackward", PRE(DYNX(W_,50), 0)
     == 0 AND Less(DYNX(W_,55),"Gear_box.sa", DYNX(W_,80),"Gear_box.tauLossMin_m",
     1) OR initial() AND Less(DYNX(W_,56),"Gear_box.w_a", 0,"0", 2));
  UpdateVariableNamed(DYNX(W_,47),"Gear_box.startForward", PRE(DYNX(W_,50), 0)
     == 0 AND Greater(DYNX(W_,55),"Gear_box.sa", DYNX(W_,79),"Gear_box.tauLossMax_p",
     3) OR initial() AND Greater(DYNX(W_,56),"Gear_box.w_a", 0,"0", 4));
  UpdateVariableNamed(DYNX(W_,49),"Gear_box.locked",  NOT (DYNX(W_,3) OR PRE(
    DYNX(W_,50), 0) == 1 OR DYNX(W_,47) OR PRE(DYNX(W_,50), 0) == -1 OR 
    DYNX(W_,48)));
  MixedModeInit(5, DYNX(DYNhelp,50))
  ThetaMixedCross(0,0)
  ThetaMixedCross(1,1)
  ThetaMixedCross(2,2)
  ThetaMixedCross(3,3)
  ThetaMixedCross(4,4)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,70), 1)
  UpdateReal(DYNX(W_,71), 2)
  UpdateReal(DYNX(W_,78), 3)
  UpdateReal(DYNX(W_,69), 4)
  UpdateReal(DYNX(W_,68), 5)
  UpdateReal(DYNX(W_,65), 6)
  UpdateReal(DYNX(W_,77), 7)
  UpdateReal(DYNX(W_,74), 8)
  UpdateReal(DYNX(W_,75), 9)
  UpdateReal(DYNX(W_,82), 10)
  UpdateReal(DYNX(W_,80), 11)
  UpdateReal(DYNX(W_,73), 12)
  UpdateReal(DYNX(W_,72), 13)
  UpdateReal(DYNX(W_,81), 14)
  UpdateReal(DYNX(W_,79), 15)
  UpdateReal(DYNX(W_,55), 16)
  UpdateReal(DYNX(W_,76), 17)
  UpdateReal(DYNX(W_,57), 18)
  UpdateReal(DYNX(W_,51), 19)
  UpdateReal(DYNX(W_,52), 20)
  UpdateReal(DYNX(F_,2), 21)
EndMixedSystemOfEquations

DYNX(W_,45) = DYNX(DP_,1)+(IF LessTime(DYNX(DP_,2), 0) THEN 0 ELSE DYNX(DP_,0));
DYNX(W_,86) = DYNX(W_,45)-DYNX(X_,2);
DYNX(F_,4) = IF DYNX(W_,34) THEN 0 ELSE divGuarded(DYNX(W_,86)-DYNX(X_,4),
  "PID.D.u-PID.D.x",DYNX(W_,31),"PID.D.T");
DYNX(F_,3) = DYNX(W_,23)*DYNX(W_,86);
DYNX(W_,91) = DYNX(W_,39)*DYNX(X_,5);
DYNX(W_,88) = DYNX(DP_,36)*DYNX(W_,86);
DYNX(W_,89) = IF DYNX(W_,34) THEN 0 ELSE divGuarded(DYNX(W_,30)*(DYNX(W_,86)-
  DYNX(X_,4)),"PID.D.k*(PID.D.u-PID.D.x)",DYNX(W_,31),"PID.D.T");
DYNX(W_,90) = DYNX(DP_,38)*DYNX(W_,88)+DYNX(DP_,39)*DYNX(X_,3)+DYNX(DP_,40)*
  DYNX(W_,89);
DYNX(W_,87) = DYNX(W_,35)*DYNX(W_,90);
DYNX(W_,92) = DYNX(W_,87)-DYNX(W_,91);
DYNX(W_,95) = DYNX(DP_,45)*DYNX(W_,56);
DYNX(W_,94) = DYNX(W_,92)-DYNX(W_,95);
 /* Linear system of equations to solve. */
DYNX(F_,5) = RememberSimple_(DYNX(F_,5), 3);
SolveScalarLinearParametric(DYNX(DP_,44),"Inductance.L", DYNX(W_,94),
  "Inductance.v", DYNX(F_,5),"der(Inductance.i)");
 /* End of Equation Block */ 

DYNX(W_,53) = DYNX(W_,76)*DYNX(W_,56);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 4);
SolveScalarLinearParametric(DYNX(DP_,24),"Gear_wall_capacitance.C", DYNX(W_,53),
  "Gear_wall_capacitance.port.Q_flow", DYNX(F_,0),"der(Gear_wall_capacitance.T)");
 /* End of Equation Block */ 


AcceptedSection1
DYNX(W_,50) = IF DYNX(W_,3) THEN 2 ELSE IF (PRE(DYNX(W_,50), 0) == 1 OR 
  DYNX(W_,47)) AND Greater(DYNX(W_,56),"Gear_box.w_a", 0,"0", 4) THEN 1 ELSE IF 
  (PRE(DYNX(W_,50), 0) == -1 OR DYNX(W_,48)) AND Less(DYNX(W_,56),"Gear_box.w_a",
   0,"0", 2) THEN -1 ELSE 0;

AcceptedSection2
DYNX(W_,54) = DYNX(DP_,3)*DYNX(X_,1);
DYNX(W_,96) = DYNX(W_,54)-DYNX(DP_,46);
 /* Linear system of equations to solve. */
DYNX(W_,83) = RememberSimple_(DYNX(W_,83), 5);
SolveScalarLinearParametric( -DYNX(DP_,25)," -Gear_wall_thermal_conduction.G", 
   -DYNX(W_,53)," -Gear_wall_thermal_conduction.Q_flow", DYNX(W_,83),
  "Gear_wall_thermal_conduction.dT");
 /* End of Equation Block */ 

DYNX(W_,84) = DYNX(W_,83)+DYNX(X_,0);
DYNX(W_,93) = DYNX(W_,91)*DYNX(X_,5);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("Propeller_reference.height", "Height of step [rad/s]", 0, 210,\
 0.0,0.0,0.0,0,560)
DeclareVariable("Propeller_reference.y", "Connector of Real output signal [rad/s]",\
 45, 0.0, 0.0,0.0,0.0,0,640)
DeclareParameter("Propeller_reference.offset", "Offset of output signal y [rad/s]",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("Propeller_reference.startTime", "Output y = offset for time < startTime [s]",\
 2, 5, 0.0,0.0,0.0,0,560)
DeclareVariable("Gear_box.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 0, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("Gear_box.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Gear_box.phi_a", 1, 5, 54, 4)
DeclareVariable("Gear_box.flange_a.tau", "Cut torque in the flange [N.m]", 51, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("Gear_box.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 4)
DeclareVariable("Gear_box.flange_b.tau", "Cut torque in the flange [N.m]", 52, \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("Gear_box.phi_support", "Absolute angle of support flange [rad|deg]",\
 1, 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("Gear_box.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 3, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 4, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 5, 0.99, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 6, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 7, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 8, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[2, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 9, 50.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[2, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 10, 0.98, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[2, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 11, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[2, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 12, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[2, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 13, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[3, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 14, 100.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[3, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 15, 0.97, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[3, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 16, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[3, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 17, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[3, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 18, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[4, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 19, 210.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[4, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 20, 0.96, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[4, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 21, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[4, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 22, 1.5, 0.0,0.0,0.0,0,560)
DeclareParameter("Gear_box.lossTable[4, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 23, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("Gear_box.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 2, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("Gear_box.heatPort.T", "Port temperature [K|degC]", \
"Gear_wall_thermal_conduction.port_a.T", 1, 5, 84, 4)
DeclareAlias2("Gear_box.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "Gear_box.lossPower", -1, 5, 53, 132)
DeclareVariable("Gear_box.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 53, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 54, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Gear_box.der(phi_a)", "der(Angle between left shaft flange and support) [rad/s]",\
 "Gear_box.w_a", 1, 5, 56, 0)
DeclareAlias2("Gear_box.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 0)
DeclareVariable("Gear_box.sa", "Path parameter for acceleration and torque loss [1]",\
 55, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.w_a", "Angular velocity of flange_a with respect to support [rad/s]",\
 56, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.der(w_a)", "der(Angular velocity of flange_a with respect to support) [rad/s2]",\
 57, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Gear_box.a_a", "Angular acceleration of flange_a with respect to support [rad/s2]",\
 "Gear_box.der(w_a)", 1, 5, 57, 0)
DeclareVariable("Gear_box.interpolation_result[1, 1]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 58, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.interpolation_result[1, 2]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 59, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.interpolation_result[1, 3]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 60, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.interpolation_result[1, 4]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 61, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.eta_mf1", "Mesh efficiency in case that flange_a is driving [1]",\
 62, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.eta_mf2", "Mesh efficiency in case that flange_b is driving [1]",\
 63, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_bf_a", "Bearing friction torque on flange_a side [N.m]",\
 64, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_eta", "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau) [N.m]",\
 65, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_bf1", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|) [N.m]",\
 66, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_bf2", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|) [N.m]",\
 67, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant1", "Torque loss if w_a > 0 and flange_a.tau >= 0 [N.m]",\
 68, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant2", "Torque loss if w_a > 0 and flange_a.tau < 0 [N.m]",\
 69, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant3", "Torque loss if w_a < 0 and flange_a.tau >= 0 [N.m]",\
 70, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant4", "Torque loss if w_a < 0 and flange_a.tau < 0 [N.m]",\
 71, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant1_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0) [N.m]",\
 72, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant2_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0) [N.m]",\
 73, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant3_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0) [N.m]",\
 74, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.quadrant4_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0) [N.m]",\
 75, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tauLoss", "Torque loss due to friction in the gear teeth and in the bearings [N.m]",\
 76, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tauLossMax", "Torque loss for positive speed [N.m]", 77,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tauLossMin", "Torque loss for negative speed [N.m]", 78,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tauLossMax_p", "Torque loss for positive speed [N.m]",\
 79, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tauLossMin_m", "Torque loss for negative speed [N.m]",\
 80, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_aPos", "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative) [:#(type=Boolean)]",\
 46, true, 0.0,0.0,0.0,0,706)
DeclareAlias2("Gear_box.tau_etaPos", "= true, if torque tau_eta is not negative [:#(type=Boolean)]",\
 "Gear_box.tau_aPos", 1, 5, 46, 65)
DeclareVariable("Gear_box.startForward", "= true, if starting to roll forward [:#(type=Boolean)]",\
 47, false, 0.0,0.0,0.0,0,706)
DeclareVariable("Gear_box.startBackward", "= true, if starting to roll backward [:#(type=Boolean)]",\
 48, false, 0.0,0.0,0.0,0,706)
DeclareVariable("Gear_box.locked", "= true, if gear is locked [:#(type=Boolean)]",\
 49, false, 0.0,0.0,0.0,0,706)
DeclareVariable("Gear_box.ideal", "= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0]) [:#(type=Boolean)]",\
 3, false, 0.0,0.0,0.0,0,515)
DeclareVariable("Gear_box.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 4, 3, 0.0,0.0,0.0,0,517)
DeclareVariable("Gear_box.Free", "Element is not active [:#(type=Integer)]", 5, 2,\
 0.0,0.0,0.0,0,517)
DeclareVariable("Gear_box.Forward", "w_a > 0 (forward rolling) [:#(type=Integer)]",\
 6, 1, 0.0,0.0,0.0,0,517)
DeclareVariable("Gear_box.Stuck", "w_a = 0 (forward rolling, locked or backward rolling) [:#(type=Integer)]",\
 7, 0, 0.0,0.0,0.0,0,517)
DeclareVariable("Gear_box.Backward", "w_a < 0 (backward rolling) [:#(type=Integer)]",\
 8, -1, 0.0,0.0,0.0,0,517)
DeclareVariable("Gear_box.mode", "Mode of friction element (unknown, not active, forward/backward rolling, stuck) [:#(type=Integer)]",\
 50, 2, -1.0,3.0,0.0,0,660)
DeclareVariable("Gear_box.tau_eta_p", "tau_eta assuming positive omega [N.m]", 81,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.tau_eta_m", "tau_eta assuming negative omega [N.m]", 82,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_box.unitAngularAcceleration", "[rad/s2]", 9, 1, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("Gear_box.unitTorque", "[N.m]", 10, 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Gear_box.eta_mf1_0", "[1]", 11, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Gear_box.eta_mf2_0", "[1]", 12, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Gear_box.tau_bf1_0", "[N.m]", 13, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Gear_box.tau_bf2_0", "[N.m]", 14, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Gear_box.tau_bf_a_0", "[N.m]", 15, 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("Gear_wall_capacitance.C", "Heat capacity of element (= cp*m) [J/K]",\
 24, 3000, 0.0,0.0,0.0,0,560)
DeclareState("Gear_wall_capacitance.T", "Temperature of element [K|degC]", 0, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareDerivative("Gear_wall_capacitance.der(T)", "der(Temperature of element) [K/s]",\
 0, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Gear_wall_capacitance.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "Gear_wall_capacitance.der(T)", 1, 6, 0, 0)
DeclareAlias2("Gear_wall_capacitance.port.T", "Port temperature [K|degC]", \
"Gear_wall_capacitance.T", 1, 1, 0, 4)
DeclareAlias2("Gear_wall_capacitance.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "Gear_box.lossPower", 1, 5, 53, 132)
DeclareAlias2("Gear_wall_thermal_conduction.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "Gear_box.lossPower", 1, 5, 53, 0)
DeclareVariable("Gear_wall_thermal_conduction.dT", "port_a.T - port_b.T [K,]", 83,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("Gear_wall_thermal_conduction.port_a.T", "Port temperature [K|degC]",\
 84, 288.15, 0.0,1E+100,300.0,0,520)
DeclareAlias2("Gear_wall_thermal_conduction.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "Gear_box.lossPower", 1, 5, 53, 132)
DeclareAlias2("Gear_wall_thermal_conduction.port_b.T", "Port temperature [K|degC]",\
 "Gear_wall_capacitance.T", 1, 1, 0, 4)
DeclareAlias2("Gear_wall_thermal_conduction.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "Gear_box.lossPower", -1, 5, 53, 132)
DeclareParameter("Gear_wall_thermal_conduction.G", "Constant thermal conductance of material [W/K]",\
 25, 100, 0.0,0.0,0.0,0,560)
DeclareVariable("Load_torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 16, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("Load_torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 4)
DeclareVariable("Load_torque.flange.tau", "Cut torque in the flange [N.m]", 85, \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("Load_torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 17, 0, 0.0,0.0,0.0,0,2561)
DeclareState("Load_torque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("Load_torque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("Load_torque.tau_nominal", "Nominal torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 26, 100, 0.0,0.0,0.0,0,560)
DeclareVariable("Load_torque.TorqueDirection", "Same direction of torque in both directions of rotation [:#(type=Boolean)]",\
 18, true, 0.0,0.0,0.0,0,515)
DeclareParameter("Load_torque.w_nominal", "Nominal speed [rad/s]", 27, 210, \
1E-15,1E+100,0.0,0,560)
DeclareAlias2("Load_torque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "Load_torque.der(phi)", 1, 6, 1, 0)
DeclareAlias2("Load_torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "Load_torque.flange.tau", -1, 5, 85, 0)
DeclareAlias2("Shaft_inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 4)
DeclareAlias2("Shaft_inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"Gear_box.flange_b.tau", -1, 5, 52, 132)
DeclareAlias2("Shaft_inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 4)
DeclareAlias2("Shaft_inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"Load_torque.flange.tau", -1, 5, 85, 132)
DeclareParameter("Shaft_inertia.J", "Moment of inertia [kg.m2]", 28, \
1.1520000000000001, 0.0,1E+100,0.0,0,560)
DeclareVariable("Shaft_inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 19, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("Shaft_inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 0)
DeclareAlias2("Shaft_inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "Shaft_inertia.w", 1, 1, 2, 0)
DeclareState("Shaft_inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("Shaft_inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Shaft_inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "Shaft_inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Load_torque.phi", 1, 1, 1, 4)
DeclareAlias2("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "Shaft_inertia.w", 1, 1, 2, 4)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 20, 0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "Shaft_inertia.w", 1, 1, 2, 0)
DeclareVariable("PID.u", "Connector of Real input signal [rad/s]", 86, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PID.y", "Connector of Real output signal [V]", 87, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("PID.k", "Gain [1]", 29, 0.08, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Ti", "Time Constant of Integrator [s]", 30, 0.17, 1E-60,\
1E+100,0.0,0,560)
DeclareParameter("PID.Td", "Time Constant of Derivative block [s]", 31, 0.5, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("PID.Nd", "The higher Nd, the more ideal the derivative block",\
 32, 10, 1E-60,1E+100,0.0,0,560)
DeclareVariable("PID.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 21, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("PID.xi_start", "Initial or guess value for integrator output (= integrator state) [rad]",\
 33, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.xd_start", "Initial or guess value for state of derivative block [rad/s]",\
 34, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.y_start", "Initial value of output [V]", 35, 0, 0.0,0.0,\
0.0,0,560)
DeclareVariable("PID.unitTime", "[s]", 22, 1, 0.0,0.0,0.0,0,1537)
DeclareParameter("PID.P.k", "Gain value multiplied with input signal [1]", 36, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.P.u", "Input signal connector [rad/s]", "PID.u", 1, 5, 86, 0)
DeclareVariable("PID.P.y", "Output signal connector [rad/s]", 88, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("PID.I.k", "Integrator gain [1]", 23, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.I.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 24, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 25, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("PID.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 26, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.I.y_start", "Initial or guess value of output (= state) [rad]",\
 27, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("PID.I.u", "Connector of Real input signal [rad/s]", "PID.u", 1, 5,\
 86, 0)
DeclareState("PID.I.y", "Connector of Real output signal [rad]", 3, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("PID.I.der(y)", "der(Connector of Real output signal) [rad/s]",\
 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("PID.I.local_reset", "[:#(type=Boolean)]", 28, false, 0.0,0.0,\
0.0,0,1539)
DeclareVariable("PID.I.local_set", "", 29, 0, 0.0,0.0,0.0,0,1537)
DeclareVariable("PID.D.k", "Gains [1]", 30, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 31, 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("PID.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 32, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("PID.D.x_start", "Initial or guess value of state [rad/s]", 33, \
0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("PID.D.y_start", "Initial value of output (= state) [rad/s2]", 37,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.D.u", "Connector of Real input signal [rad/s]", "PID.u", 1, 5,\
 86, 0)
DeclareVariable("PID.D.y", "Connector of Real output signal [rad/s2]", 89, 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("PID.D.x", "State of block [rad/s]", 4, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PID.D.der(x)", "der(State of block) [rad/s2]", 4, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("PID.D.zeroGain", "[:#(type=Boolean)]", 34, false, 0.0,0.0,0.0,0,2563)
DeclareVariable("PID.Gain.k", "Gain value multiplied with input signal [1]", 35,\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("PID.Gain.u", "Input signal connector", 90, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("PID.Gain.y", "Output signal connector [V]", "PID.y", 1, 5, 87, 0)
DeclareParameter("PID.Add.k1", "Gain of input signal 1", 38, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Add.k2", "Gain of input signal 2", 39, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("PID.Add.k3", "Gain of input signal 3", 40, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("PID.Add.u1", "Connector of Real input signal 1 [rad/s]", \
"PID.P.y", 1, 5, 88, 0)
DeclareAlias2("PID.Add.u2", "Connector of Real input signal 2 [rad]", "PID.I.y", 1,\
 1, 3, 0)
DeclareAlias2("PID.Add.u3", "Connector of Real input signal 3 [rad/s2]", \
"PID.D.y", 1, 5, 89, 0)
DeclareAlias2("PID.Add.y", "Connector of Real output signal", "PID.Gain.u", 1, 5,\
 90, 0)
DeclareAlias2("signalVoltage.p.v", "Potential at the pin [V]", "PID.y", 1, 5, 87,\
 4)
DeclareAlias2("signalVoltage.p.i", "Current flowing into the pin [A]", \
"Inductance.i", -1, 1, 5, 132)
DeclareVariable("signalVoltage.n.v", "Potential at the pin [V]", 36, 0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("signalVoltage.n.i", "Current flowing into the pin [A]", \
"Inductance.i", 1, 1, 5, 132)
DeclareAlias2("signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "PID.y", 1, 5, 87, 0)
DeclareAlias2("signalVoltage.i", "Current flowing from pin p to pin n [A]", \
"Inductance.i", -1, 1, 5, 0)
DeclareAlias2("feedback.u1", "Commanded input [rad/s]", "Propeller_reference.y", 1,\
 5, 45, 0)
DeclareAlias2("feedback.u2", "Feedback input [rad/s]", "Shaft_inertia.w", 1, 1, 2,\
 0)
DeclareAlias2("feedback.y", "[rad/s]", "PID.u", 1, 5, 86, 0)
DeclareParameter("Coil_resistance.R", "Resistance at temperature T_ref [Ohm]", 41,\
 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("Coil_resistance.T_ref", "Reference temperature [K|degC]", 42, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("Coil_resistance.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 43, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("Coil_resistance.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 91, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Coil_resistance.p.v", "Potential at the pin [V]", "PID.y", 1, 5, 87,\
 4)
DeclareAlias2("Coil_resistance.p.i", "Current flowing into the pin [A]", \
"Inductance.i", 1, 1, 5, 132)
DeclareVariable("Coil_resistance.n.v", "Potential at the pin [V]", 92, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("Coil_resistance.n.i", "Current flowing into the pin [A]", \
"Inductance.i", -1, 1, 5, 132)
DeclareAlias2("Coil_resistance.i", "Current flowing from pin p to pin n [A]", \
"Inductance.i", 1, 1, 5, 0)
DeclareVariable("Coil_resistance.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 37, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Coil_resistance.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 38, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("Coil_resistance.LossPower", "Loss power leaving component via heatPort [W]",\
 93, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Coil_resistance.T_heatPort", "Temperature of heatPort [K|degC]", \
"Coil_resistance.T", 1, 5, 38, 0)
DeclareVariable("Coil_resistance.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 39, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Inductance.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 94, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Inductance.p.v", "Potential at the pin [V]", "Coil_resistance.n.v", 1,\
 5, 92, 4)
DeclareAlias2("Inductance.p.i", "Current flowing into the pin [A]", \
"Inductance.i", 1, 1, 5, 132)
DeclareVariable("Inductance.n.v", "Potential at the pin [V]", 95, 0.0, 0.0,0.0,\
0.0,0,520)
DeclareAlias2("Inductance.n.i", "Current flowing into the pin [A]", \
"Inductance.i", -1, 1, 5, 132)
DeclareState("Inductance.i", "Current flowing from pin p to pin n [A]", 5, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("Inductance.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("Inductance.L", "Inductance [H]", 44, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("Motor_constant.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 40, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("Motor_constant.k", "Transformation coefficient [N.m/A]", 45, \
0.3, 0.0,0.0,0.0,0,560)
DeclareAlias2("Motor_constant.v", "Voltage drop between the two pins [V]", \
"Inductance.n.v", 1, 5, 95, 0)
DeclareAlias2("Motor_constant.i", "Current flowing from positive to negative pin [A]",\
 "Inductance.i", 1, 1, 5, 0)
DeclareVariable("Motor_constant.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 96, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Motor_constant.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "Gear_box.w_a", 1, 5, 56, 0)
DeclareAlias2("Motor_constant.w", "Angular velocity of flange relative to support [rad/s]",\
 "Gear_box.w_a", 1, 5, 56, 0)
DeclareVariable("Motor_constant.tau", "Torque of flange [N.m]", 97, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("Motor_constant.tauElectrical", "Electrical torque [N.m]", \
"Motor_constant.tau", -1, 5, 97, 0)
DeclareAlias2("Motor_constant.p.v", "Potential at the pin [V]", "Inductance.n.v", 1,\
 5, 95, 4)
DeclareAlias2("Motor_constant.p.i", "Current flowing into the pin [A]", \
"Inductance.i", 1, 1, 5, 132)
DeclareVariable("Motor_constant.n.v", "Potential at the pin [V]", 41, 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("Motor_constant.n.i", "Current flowing into the pin [A]", \
"Inductance.i", -1, 1, 5, 132)
DeclareAlias2("Motor_constant.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Gear_box.phi_a", 1, 5, 54, 4)
DeclareAlias2("Motor_constant.flange.tau", "Cut torque in the flange [N.m]", \
"Motor_constant.tau", 1, 5, 97, 132)
DeclareParameter("Motor_constant.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 46, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("Motor_constant.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Motor_constant.fixed.phi0", 1, 7, 46, 1028)
DeclareAlias2("Motor_constant.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "Motor_constant.tau", 1, 5, 97, 1156)
DeclareAlias2("Motor_constant.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "Motor_constant.tau", -1, 5, 97, 1024)
DeclareAlias2("Motor_constant.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "Motor_constant.fixed.phi0", 1, 7, 46, 1024)
DeclareAlias2("Motor_constant.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Motor_constant.fixed.phi0", 1, 7, 46, 1028)
DeclareAlias2("Motor_constant.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "Motor_constant.tau", -1, 5, 97, 1156)
DeclareVariable("Ground.p.v", "Potential at the pin [V]", 42, 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("Ground.p.i", "Current flowing into the pin [A]", 43, 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("Motor_inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Gear_box.phi_a", 1, 5, 54, 4)
DeclareAlias2("Motor_inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"Motor_constant.tau", -1, 5, 97, 132)
DeclareAlias2("Motor_inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "Gear_box.phi_a", 1, 5, 54, 4)
DeclareAlias2("Motor_inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"Gear_box.flange_a.tau", -1, 5, 51, 132)
DeclareParameter("Motor_inertia.J", "Moment of inertia [kg.m2]", 47, 0.001, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("Motor_inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 44, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("Motor_inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "Gear_box.phi_a", 1, 5, 54, 0)
DeclareAlias2("Motor_inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "Gear_box.w_a", 1, 5, 56, 0)
DeclareAlias2("Motor_inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "Gear_box.w_a", 1, 5, 56, 0)
DeclareAlias2("Motor_inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "Gear_box.der(w_a)", 1, 5, 57, 0)
DeclareAlias2("Motor_inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "Gear_box.der(w_a)", 1, 5, 57, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preD(DYNX(W_,50),"Gear_box.mode", 2, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,55), 0.0, 0);
DoRemember_(DYNX(W_,76), 0.0, 1);
DoRememAcc_(DYNX(W_,83), 0.0, 5);
DoRemember_(DYNX(F_,0), 0, 4);
DoRemember_(DYNX(F_,5), 0.0, 3);
DoRemember_(DYNX(F_,2), 0.0, 2);
EndEqBlock
EndDataBlock
